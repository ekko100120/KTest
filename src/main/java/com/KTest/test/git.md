#### git command recorder

###### HEAD
[HEAD] :在 Git 中，它是一个指向你正在工作中的本地分支的指针（译注：将 HEAD 想象为当前分支的别名。）

******************
##### [git diff]
* [git diff] ：比较的是工作目录中当前文件和暂存区域快照之间的差异
* [git diff --staged]:看已经暂存起来的文件和上次提交时的快照之间的差异
* []

**********
#### [git commit]
* [git commit -m] 提交已暂存的文件
* [git commit -a] 提交工作区和已暂存的所有文件(Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤  == git add +git commit)
* [git commit --amend]

*************
#### [git rm VS rm]

* [git rm]&&[git rm -f ]从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。
* [git rm --cached ]  把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。
* [git rm \*~] 地柜删除当前目录及其子目录中所有~结尾的文字(\递归删除)
***********
####[git add]
* [git add .] 全部添加到暂存区


*****************************
* [git remote] 会列出每个远程库的简短名字
* [git remote -v] 也可以加上 -v 选项（译注：此为 --verbose 的简写，取首字母），显示对应的克隆地址：
* [git remote add [shortname] [url]] 要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用

* [git remote show]  查看某个远程仓库的详细信息

* [git remote rename] 远程仓库重命名 

** [git remote rm]   远程仓库删除


***********************
#### git fetch VS git pull

* [git fetch]  fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。
* [git pull]   使用 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好

**********************
#### git push 

* [git push [remote-name] [branch-name]] 如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令; 只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务


*******************
#####  git tag
> Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题
*  [git tag] 列出现有所有标签
*  [git tag -l ] 用特定的搜索模式列出符合条件的标签

*  [git tag -a] 

*  [git push origin [tagname]/--tags] ：默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓